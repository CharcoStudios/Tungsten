<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Tungsten</name>
  </assembly>
  <members>
    <member name="T:W.ActionQueue`1">
      <summary>
        <para>
            Allows the programmer to enqueue items for processing on a separate thread.  The ActionQueue will process items sequentially whenever an item is added.
            </para>
      </summary>
      <typeparam name="T">The type of data to enqueue and process</typeparam>
    </member>
    <member name="P:W.ActionQueue`1.Count">
      <summary>
            Returns the number of items currently in the queue
            </summary>
    </member>
    <member name="P:W.ActionQueue`1.Queue">
      <summary>
            The reference to the ConcurrentQueue being used
            </summary>
    </member>
    <member name="M:W.ActionQueue`1.Enqueue(`0)">
      <summary>
            Places an item in the queue
            </summary>
      <param name="item">The item to place in the queue</param>
    </member>
    <member name="M:W.ActionQueue`1.Cancel">
      <summary>
            Cancels processing of the queue
            </summary>
    </member>
    <member name="M:W.ActionQueue`1.Dispose">
      <summary>
            Releases resources related to the ActionQueue
            </summary>
    </member>
    <member name="M:W.ActionQueue`1.#ctor(System.Func{`0,System.Boolean},System.String)">
      <summary>
            Creates a new ActionQueue
            </summary>
      <param name="onItemAdded">A callback which is called whenever an item has been enqueued</param>
      <param name="caller">The name of the method which invoked this constructor</param>
    </member>
    <member name="M:W.ActionQueue`1.#ctor(System.Action{`0},System.String)">
      <summary>
            Creates a new ActionQueue
            </summary>
      <param name="onItemAdded">A callback which is called whenever an item has been enqueued</param>
      <param name="caller">The name of the method which invoked this constructor</param>
    </member>
    <member name="M:W.ActionQueue`1.Finalize">
      <summary>
            Disposes the ActionQueue
            </summary>
    </member>
    <member name="T:W.AsExtensions">
      <summary>
            Extensions which convert objects of one type to another
            </summary>
    </member>
    <member name="M:W.AsExtensions.As``1(System.Object)">
      <summary>
            Use Generic syntax for the <bold>as</bold> operator.
            </summary>
      <typeparam name="TType">The type to convert the item reference to.</typeparam>
      <param name="this">The item to convert to type TType</param>
      <returns>Null if @this cannot be referenced as TType.  Otherwise, the item as TType</returns>
      <example>
        <code>expression as type</code> becomes <code>expression&lt;type&gt;()</code></example>
    </member>
    <member name="M:W.AsExtensions.AsBase64(System.String)">
      <summary>
            Converts a string to Base64 encoding
            </summary>
      <param name="this">The string to convert to Base64 encoding</param>
      <returns>The Base64 encoded string</returns>
    </member>
    <member name="M:W.AsExtensions.AsBase64(System.Byte[])">
      <summary>
            Converts a byte array to a Base64 encoded string
            </summary>
      <param name="this">The string to convert to Base64 encoding</param>
      <returns>The Base64 encoded string</returns>
    </member>
    <member name="M:W.AsExtensions.AsBytes(System.String)">
      <summary>
            Converts a string to an encoded byte array
            </summary>
      <param name="this">The string to convert to an encoded byte array</param>
      <returns>A byte array encoding of the specified string</returns>
    </member>
    <member name="M:W.AsExtensions.AsString(System.Byte[])">
      <summary>
            Converts an encoded byte array to a string
            </summary>
      <param name="this">The encoded byte array to conver to a string</param>
      <returns>The string representation of the encoded byte array</returns>
    </member>
    <member name="M:W.AsExtensions.AsString(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Converts an encoded byte array to a string
            </summary>
      <param name="this">The encoded byte array to conver to a string</param>
      <param name="index">The starting index</param>
      <param name="count">The number of bytes to convert</param>
      <returns>The string representation of the encoded byte array</returns>
    </member>
    <member name="M:W.AsExtensions.AsStream(System.Byte[])">
      <summary>
            Creates a MemoryStream object and initializes it with the specified byte array
            </summary>
      <param name="this">The byte array used in creating the MemoryStream</param>
      <returns>A new MemoryStream initialized with the specified byte array</returns>
    </member>
    <member name="M:W.AsExtensions.AsStream(System.String)">
      <summary>
            Creates a MemoryStream object and initializes it with the specified string
            </summary>
      <param name="this">The string used in creating the MemoryStream</param>
      <returns>A new MemoryStream initilized with the specified string</returns>
    </member>
    <member name="M:W.AsExtensions.AsJson``1(System.Object)">
      <summary>
            Serializes an object to a Json string
            </summary>
      <typeparam name="TType">The type of object to serialize</typeparam>
      <param name="this">The object to serialize to Json</param>
      <returns>A Json formatted string representation of the specified object</returns>
    </member>
    <member name="M:W.AsExtensions.AsXml``1(System.Object)">
      <summary>
            Serializes an object to an xml string
            </summary>
      <typeparam name="TType">The type of object to serialize</typeparam>
      <param name="this">The object to serialize</param>
      <returns>A string containing the object as serialized into xml</returns>
    </member>
    <member name="M:W.AsExtensions.AsCompressed(System.Byte[])">
      <summary>
            Compresses the byte array using System.IO.Compression.DeflateStream
            </summary>
      <param name="bytes">The byte array to compress</param>
      <returns>A byte array of compressed data</returns>
    </member>
    <member name="M:W.AsExtensions.AsDecompressed(System.Byte[])">
      <summary>
            Decompresses the byte array using System.IO.Compression.DeflateStream
            </summary>
      <param name="bytes">The byte array containing compressed data</param>
      <returns>A byte array of the decompressed data</returns>
    </member>
    <member name="T:W.CallResult`1">
      <summary>
        <para>
            Generic class to be used as a return value.  CallResult encapsulates a success/failure, an exception and a return value.
            </para>
      </summary>
      <typeparam name="TResult">The type to be used for the Result member (the return value of the function)</typeparam>
    </member>
    <member name="P:W.CallResult`1.Result">
      <summary>
            The return value
            </summary>
    </member>
    <member name="M:W.CallResult`1.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:W.CallResult`1.#ctor(System.Boolean)">
      <summary>
            Constructor accepting an initial Success value
            </summary>
      <param name="success">The initial Success value</param>
    </member>
    <member name="M:W.CallResult`1.#ctor(System.Boolean,`0)">
      <summary>
            Constructor accepting an initial Success value and an initial Result value
            </summary>
      <param name="success">The initial Success value</param>
      <param name="result">The initial Result value</param>
    </member>
    <member name="M:W.CallResult`1.#ctor(System.Boolean,`0,System.Exception)">
      <summary>
            Constructor accepting an initial Success value, an initial Result value and an initial Exception value
            </summary>
      <param name="success">The initial value for Success</param>
      <param name="result">The initial Result value</param>
      <param name="e">An exception object, if an exception occurred</param>
    </member>
    <member name="P:W.CallResult`1.Empty">
      <summary>
            Provides a new instance of an uninitialized CallResult&lt;TResult&gt;
            </summary>
    </member>
    <member name="T:W.CallResult">
      <summary>
            A non-generic return value for a function.  CallResult encapsulates a success/failure and an exception.
            </summary>
    </member>
    <member name="P:W.CallResult.Success">
      <summary>
            Set to True if the function succeeds, otherwise False
            </summary>
    </member>
    <member name="P:W.CallResult.Exception">
      <summary>
            Provide exception data to the caller if desired
            </summary>
    </member>
    <member name="M:W.CallResult.#ctor">
      <summary>
            Default constructor, initializes Success to false
            </summary>
    </member>
    <member name="M:W.CallResult.#ctor(System.Boolean)">
      <summary>
            Constructor which accepts an initial value for Success
            </summary>
      <param name="success">The initial value for Success</param>
    </member>
    <member name="M:W.CallResult.#ctor(System.Boolean,System.Exception)">
      <summary>
            Constructor which accepts an initial value for Success and an initial value for Exception
            </summary>
      <param name="success">The initial value for Success</param>
      <param name="e">The initial value for Exception</param>
    </member>
    <member name="P:W.CallResult.Empty">
      <summary>
            Provides a new instance of an uninitialized CallResult
            </summary>
    </member>
    <member name="T:W.Disposable">
      <summary>
            Provides the Disposable pattern as a base class
            </summary>
    </member>
    <member name="F:W.Disposable.IsDisposed">
      <summary>
            If True, the object has been disposed
            </summary>
    </member>
    <member name="F:W.Disposable.IsDisposing">
      <summary>
            If True, the object is in the process of disposing
            </summary>
    </member>
    <member name="M:W.Disposable.OnDisposeUnmanaged">
      <summary>
            Override to release unmanaged objects
            </summary>
    </member>
    <member name="M:W.Disposable.OnDispose">
      <summary>
            Overload to dispose managed objects
            </summary>
    </member>
    <member name="M:W.Disposable.Finalize">
      <summary>
            Override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.
            </summary>
    </member>
    <member name="M:W.Disposable.Dispose">
      <summary>
            This code added to correctly implement the disposable pattern.
            </summary>
    </member>
    <member name="T:W.Encryption.MD5">
      <summary>
            Used to generate MD5 hashes and verify input strings against them
            </summary>
    </member>
    <member name="M:W.Encryption.MD5.GetMd5Hash(System.String)">
      <summary>
            Generates an MD5 hash of the input string
            </summary>
      <param name="input">An MD5 hash of this input will be created</param>
      <returns>An MD5 hash of the inputted value</returns>
    </member>
    <member name="M:W.Encryption.MD5.GetMd5Hash(System.String,System.Security.Cryptography.MD5)">
      <summary>
            Generates an MD5 hash of the input string
            </summary>
      <param name="input">An MD5 hash of this input will be created</param>
      <param name="md5">The previously allocated MD5 object to use</param>
      <returns>An MD5 hash of the inputted value</returns>
    </member>
    <member name="M:W.Encryption.MD5.VerifyMd5Hash(System.String,System.String)">
      <summary>
            Verifies a hash against a string
            </summary>
      <param name="input">The string to verify</param>
      <param name="hash">The MD5 hash used in the verification</param>
      <returns>True if the input string is verified, otherwise False</returns>
    </member>
    <member name="T:W.Encryption.PublicPrivateKeyPair">
      <summary>
            The public and private RSA keys
            </summary>
    </member>
    <member name="P:W.Encryption.PublicPrivateKeyPair.PrivateKey">
      <summary>
            The private RSA key.  Should never be shared.
            </summary>
    </member>
    <member name="P:W.Encryption.PublicPrivateKeyPair.PublicKey">
      <summary>
            the public RSA key. Should be shared.
            </summary>
    </member>
    <member name="T:W.Encryption.RSAMethods">
            Warning is overriding an error
            XML comment has syntactically incorrect cref attribute
            <summary><para>
            Replaces RSA.  This code was adaptd for NetStandard from an article published on CodeProject by Mathew John Schlabaugh in 2007.  It is less complicated but works more often than my initial RSA implementation. See: https://www.codeproject.com/Articles/10877/Public-Key-RSA-Encryption-in-C-NET
            </para></summary><see cref="!:https://www.codeproject.com/Articles/10877/Public-Key-RSA-Encryption-in-C-NET" /></member>
    <member name="M:W.Encryption.RSAMethods.LegalKeySizes">
      <summary>
            Returns an arrary containing the supported key sizes
            </summary>
      <returns>An array of supported key sizes</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.CreateKeyPair(System.Int32)">
      <summary>
            Generates a public/private key pair
            </summary>
      <param name="keySize">The key size to use when creating the public and private keys</param>
      <returns>A newly created PublicPrivateKeyPair containing the public and private keys</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.Encrypt(System.String,System.Security.Cryptography.RSAParameters)">
      <summary>
            Encrypts a string using the specified keysize and public key
            </summary>
      <param name="inputString">The data to encrypt</param>
      <param name="publicKey">The public key used to encrypt the data</param>
      <returns>A string containing the encrypted data</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.Decrypt(System.String,System.Security.Cryptography.RSAParameters)">
      <summary>
            Decrypts a string which was previously encrypted with the Encrypt method
            </summary>
      <param name="cipher">The encrypted byte array</param>
      <param name="privateKey">The private key used to decrypt the data</param>
      <returns>A byte array containing the decrypted value</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.EncryptAsync(System.String,System.Security.Cryptography.RSAParameters)">
      <summary>
            Asynchronously encrypts a string using the specified keysize and public key
            </summary>
      <param name="inputString">The data to encrypt</param>
      <param name="publicKey">The public key used to encrypt the data</param>
      <returns>A string containing the encrypted data</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.DecryptAsync(System.String,System.Security.Cryptography.RSAParameters)">
      <summary>
            Asynchronously decrypts a string which was previously encrypted with the Encrypt method
            </summary>
      <param name="cipher">The encrypted byte array</param>
      <param name="privateKey">The private key used to decrypt the data</param>
      <returns>A byte array containing the decrypted value</returns>
    </member>
    <member name="T:W.EventTemplate">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
    </member>
    <member name="T:W.EventTemplate.EventDelegate">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
      <param name="args">An array of untyped arguments</param>
    </member>
    <member name="E:W.EventTemplate.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate.Raise(System.Object,System.String,System.Object[])">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
      <param name="args">An array of untyped arguments</param>
    </member>
    <member name="T:W.EventTemplate`1">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg">The detailed event argument</typeparam>
    </member>
    <member name="T:W.EventTemplate`1.EventDelegate">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg">The detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="E:W.EventTemplate`1.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`1.Raise(System.Object,`0,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg">The detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate`2">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg1">The first detailed event argument</typeparam>
      <typeparam name="TEventArg2">The second detailed event argument</typeparam>
    </member>
    <member name="T:W.EventTemplate`2.EventDelegate">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="E:W.EventTemplate`2.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`2.Raise(System.Object,`0,`1,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate`3">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg1">The first detailed event argument</typeparam>
      <typeparam name="TEventArg2">The second detailed event argument</typeparam>
      <typeparam name="TEventArg3">The third detailed event argument</typeparam>
    </member>
    <member name="T:W.EventTemplate`3.EventDelegate">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="E:W.EventTemplate`3.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`3.Raise(System.Object,`0,`1,`2,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate`4">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg1">The first detailed event argument</typeparam>
      <typeparam name="TEventArg2">The second detailed event argument</typeparam>
      <typeparam name="TEventArg3">The third detailed event argument</typeparam>
      <typeparam name="TEventArg4">The fourth detailed event argument</typeparam>
    </member>
    <member name="T:W.EventTemplate`4.EventDelegate">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="arg4">The fourth detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="E:W.EventTemplate`4.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`4.Raise(System.Object,`0,`1,`2,`3,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="arg4">The fourth detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate`5">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg1">The first detailed event argument</typeparam>
      <typeparam name="TEventArg2">The second detailed event argument</typeparam>
      <typeparam name="TEventArg3">The third detailed event argument</typeparam>
      <typeparam name="TEventArg4">The fourth detailed event argument</typeparam>
      <typeparam name="TEventArg5">The fifth detailed event argument</typeparam>
    </member>
    <member name="T:W.EventTemplate`5.EventDelegate">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="arg4">The fourth detailed event argument</param>
      <param name="arg5">The fifth detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="E:W.EventTemplate`5.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`5.Raise(System.Object,`0,`1,`2,`3,`4,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="arg4">The fourth detailed event argument</param>
      <param name="arg5">The fifth detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.FromExtensions">
      <summary>
            Extensions which convert objects of one type to another
            </summary>
    </member>
    <member name="M:W.FromExtensions.FromBase64(System.String)">
      <summary>
            Converts a Base64 encoded string back to a normal string
            </summary>
      <param name="this">The Base64 encoded string to convert</param>
      <returns>A non-encoded string</returns>
    </member>
    <member name="M:W.FromExtensions.FromBase64(System.Byte[])">
      <summary>
            Converts a Base64 encoded byte array back to a normal byte array
            </summary>
      <param name="this">The Base64 encoded byte array to convert</param>
      <returns>A non-encoded string</returns>
    </member>
    <member name="M:W.FromExtensions.FromJson``1(System.String)">
      <summary>
            Deserializes a Json string to an object
            </summary>
      <typeparam name="TType">The type of object to deserialize</typeparam>
      <param name="this">The Json formatted string</param>
      <returns>A new instance of TType deserialized from the specified Json string</returns>
    </member>
    <member name="M:W.FromExtensions.FromJson``1(System.Byte[])">
      <summary>
            Deserializes an encoded byte array of Json to an object
            </summary>
      <typeparam name="TType">The type of object to deserialize</typeparam>
      <param name="this">The byte array containing encoded Json</param>
      <returns>A new instance of TType deserialized from the specified Json encoded byte array</returns>
    </member>
    <member name="M:W.FromExtensions.FromXml``1(System.String)">
      <summary>
            Deserializes an Xml string to an object
            </summary>
      <typeparam name="TType">The type of object to deserialize</typeparam>
      <param name="this">The Json formatted string</param>
      <returns>A new instance of TType deserialized from the specified Xml string</returns>
    </member>
    <member name="M:W.FromExtensions.FromXml``1(System.Byte[])">
      <summary>
            Deserializes an Xml string to an object
            </summary>
      <typeparam name="TType">The type of object to deserialize</typeparam>
      <param name="this">The Xml formatted string</param>
      <returns>A new instace of TType deserialized from the specified Xml string</returns>
    </member>
    <member name="M:W.FromExtensions.FromCompressed(System.Byte[])">
      <summary>
            Decompresses the byte array using System.IO.Compression.DeflateStream
            </summary>
      <param name="bytes">The byte array containing compressed data</param>
      <returns>A byte array of the decompressed data</returns>
    </member>
    <member name="T:W.InvokeExtensions">
      <summary>
            Extension methods to provide code shortcuts to evaluate InvokeRequired and run code appropriately
            </summary>
    </member>
    <member name="M:W.InvokeExtensions.InvokeEx``1(``0,System.Action{``0})">
      <summary>
            Runs the provided Action on the UI thread
            </summary>
      <param name="this">The form or control which supports ISynchronizeInvoke</param>
      <param name="action">The code to be executed on the UI thread</param>
      <typeparam name="T">The form or control who's thread will execute the code</typeparam>
    </member>
    <member name="M:W.InvokeExtensions.InvokeEx``2(``0,System.Func{``0,``1})">
      <summary>
            Runs the provided Function on the UI thread. Avoids the cross-threaded exceptions.
            </summary>
      <param name="this">The form or control which supports ISynchronizationInvoke</param>
      <param name="f">The function to be executed on the UI thread</param>
      <typeparam name="T">The form or control who's thread will execute the code</typeparam>
      <typeparam name="U">The type of return value</typeparam>
      <returns>The function should return an object of type U</returns>
    </member>
    <member name="M:W.InvokeExtensions.InvokeEx``1(``0,System.Func{``0,System.Object})">
      <summary>
            Runs the provided Function on the UI thread. Avoids the cross-threaded exceptions.
            </summary>
      <param name="this">The form or control which supports ISynchronizationInvoke</param>
      <param name="f">The function to be executed on the UI thread</param>
      <typeparam name="T">The form or control who's thread will execute the code</typeparam>
      <returns>The function should return an object</returns>
    </member>
    <member name="T:W.Lockable`1">
      <summary>
        <para>
            Provides thread safety via locking
            </para>
      </summary>
      <typeparam name="TValue">The Type of the lockable value</typeparam>
    </member>
    <member name="P:W.Lockable`1.LockObject">
      <summary>
            The object used internally for lock statements
            </summary>
    </member>
    <member name="P:W.Lockable`1.Value">
      <summary>
        <para>
            Provides automatic locking during read/writes
            </para>
      </summary>
    </member>
    <member name="P:W.Lockable`1.UnlockedValue">
      <summary>
        <para>
            To be used by caller, with LockObject, to batch read/writes under one lock)
            </para>
      </summary>
    </member>
    <member name="M:W.Lockable`1.ExecuteInLock(System.Action{`0})">
      <summary>
            Executes an action within a lock of the LockObject
            </summary>
      <param name="action">The action to call within a lock</param>
    </member>
    <member name="M:W.Lockable`1.ExecuteInLock(System.Func{`0,`0})">
      <summary>
            Executes an action within a lock of the LockObject
            </summary>
      <param name="function">The function to call within a lock</param>
    </member>
    <member name="M:W.Lockable`1.ExecuteInLockAsync(System.Action{`0})">
      <summary>
            Executes a task within a lock of the LockObject
            </summary>
      <param name="action">The action to call within a lock</param>
    </member>
    <member name="M:W.Lockable`1.ExecuteInLockAsync(System.Func{`0,`0})">
      <summary>
            Executes a task within a lock of the LockObject
            </summary>
      <param name="function">The function to call within a lock</param>
    </member>
    <member name="M:W.Lockable`1.#ctor">
      <summary>
        <para>
            Constructor which initializes Value with the default of TValue
            </para>
      </summary>
    </member>
    <member name="M:W.Lockable`1.#ctor(`0)">
      <summary>
            Constructor which initializes Value with the specified value
            </summary>
      <param name="value">The initial value for Value</param>
    </member>
    <member name="T:W.Logging.CustomLogger">
      <summary>
            Allows the programmer to add a custom message logger
            </summary>
    </member>
    <member name="P:W.Logging.CustomLogger.Name">
      <summary>
            The name of this custom logger
            </summary>
    </member>
    <member name="P:W.Logging.CustomLogger.AddTimestamp">
      <summary>
            If true, FormatLogMessage will, by default, add a timestamp prefix to the log message
            </summary>
      <remarks>Note that if FormatLogMessage is overridden, this functionality may be overridden</remarks>
    </member>
    <member name="P:W.Logging.CustomLogger.IsDisposed">
      <summary>
            True if OnDispose has been called
            </summary>
    </member>
    <member name="M:W.Logging.CustomLogger.FormatLogMessage(W.Logging.Log.LogMessageCategory,System.String)">
      <summary>
            Formats the Log Messge (if AddTimestamp is true, the message is prefixed with a timestamp)
            </summary>
      <param name="category">The log message category</param>
      <param name="message">The log message</param>
      <returns>The formatted log message</returns>
    </member>
    <member name="M:W.Logging.CustomLogger.LogMessage(W.Logging.Log.LogMessageCategory,System.String)">
      <summary>
            Log a message to the custom logger
            </summary>
      <param name="category">The log message category</param>
      <param name="message">The log message</param>
    </member>
    <member name="M:W.Logging.CustomLogger.OnDispose">
      <summary>
            Disposes the CustomLogger, releases resources and supresses the finalizer
            </summary>
    </member>
    <member name="M:W.Logging.CustomLogger.Dispose">
      <summary>
            Disposes the CustomLogger and releases resources
            </summary>
    </member>
    <member name="M:W.Logging.CustomLogger.#ctor(System.String,System.Boolean)">
      <summary>
            Constructs a new CustomLogger
            </summary>
      <param name="name">The custom logger name</param>
      <param name="addTimestamp">If True the log messages will be prefixed with a timestamp</param>
    </member>
    <member name="T:W.Logging.Log">
      <summary>
            Exposes static methods for logging.  LogTheMessage can be assigned a new value for customized logging.
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogTheMessage">
      <summary>
            Configure this Action to log messages the way you like to
            </summary>
      <remarks>This method needs to be replaced with something useful to you.</remarks>
    </member>
    <member name="T:W.Logging.Log.LogMessageCategory">
      <summary>
            The log message type
            </summary>
    </member>
    <member name="F:W.Logging.Log.LogMessageCategory.Verbose">
      <summary>
            Denotes verbose message
            </summary>
    </member>
    <member name="F:W.Logging.Log.LogMessageCategory.Information">
      <summary>
            Denotes a informational message
            </summary>
    </member>
    <member name="F:W.Logging.Log.LogMessageCategory.Warning">
      <summary>
            Denotes a warning message
            </summary>
    </member>
    <member name="F:W.Logging.Log.LogMessageCategory.Error">
      <summary>
            Denotes an error message
            </summary>
    </member>
    <member name="M:W.Logging.Log.e(System.Exception)">
            Parameter has no matching param tag in the XML comment (but other parameters do)
            <summary>
            Log an Exception
            </summary><param name="e">The exception to log.  This will be boxed with ToString().</param></member>
    <member name="M:W.Logging.Log.e(System.String,System.Object[])">
      <summary>
            Log a formatted exception message. This method uses string.Format to format the message.
            </summary>
      <param name="format">Format of the message</param>
      <param name="args">Parameters to be passed during message formatting</param>
    </member>
    <member name="M:W.Logging.Log.w(System.String,System.String,System.Int32)">
            Parameter has no matching param tag in the XML comment (but other parameters do)
             <summary>
             Log a formatted warning message. This method uses string.Format to format the message.
             </summary><param name="message">Format of the message</param><param name="callerName">The name of the caller</param><param name="callerLineNumber">The line number of the caller</param></member>
    <member name="M:W.Logging.Log.w(System.String,System.Object[])">
      <summary>
            Log a formatted warning message. This method uses string.Format to format the message.
            </summary>
      <param name="format">Format of the message</param>
      <param name="args">Parameters to be passed during message formatting</param>
    </member>
    <member name="M:W.Logging.Log.i(System.String,System.String,System.Int32)">
            Parameter has no matching param tag in the XML comment (but other parameters do)
            <summary>
            Log a formatted informational message. This method uses string.Format to format the message.
            </summary><param name="message">Format of the message</param><param name="callerName">The name of the caller</param><param name="callerLineNumber">The line number of the caller</param></member>
    <member name="M:W.Logging.Log.i(System.String,System.Object[])">
      <summary>
            Log a formatted informational message. This method uses string.Format to format the message.
            </summary>
      <param name="format">Format of the message</param>
      <param name="args">Parameters to be passed during message formatting</param>
    </member>
    <member name="M:W.Logging.Log.v(System.String,System.String,System.Int32)">
            Parameter has no matching param tag in the XML comment (but other parameters do)
            <summary>
            Log a formatted verbose message. This method uses string.Format to format the message.
            </summary><param name="message">Format of the message</param><param name="callerName">The name of the caller</param><param name="callerLineNumber">The line number of the caller</param></member>
    <member name="M:W.Logging.Log.v(System.String,System.Object[])">
      <summary>
            Log a formatted verbose message. This method uses string.Format to format the message.
            </summary>
      <param name="format">Format of the message</param>
      <param name="args">Parameters to be passed during message formatting</param>
    </member>
    <member name="P:W.Logging.Log.MessageHistory">
      <summary>
            A maintained history of log messages
            </summary>
      <remarks>The default log message limit is 10,000 messages</remarks>
    </member>
    <member name="T:W.Logging.Log.LogMessageHistory">
      <summary>
            Maintains a history of Log information
            </summary>
    </member>
    <member name="T:W.Logging.Log.LogMessageHistory.LogMessage">
      <summary>
            An individual log message
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.LogMessage.Category">
      <summary>
            The category of the log message
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.LogMessage.Message">
      <summary>
            The logged message
            </summary>
    </member>
    <member name="M:W.Logging.Log.LogMessageHistory.LogMessage.#ctor">
      <summary>
            Constructs a new LogMessage
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.Messages">
      <summary>
            The history of log messages
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.MaximumNumberOfMessages">
      <summary>
            The maximum number of historical messages to maintain.  When the maximum is reached, the oldest messages are removed as needed.
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.Enabled">
      <summary>
            If True, log messages will be added to the history.  If False, no history is maintained.
            </summary>
    </member>
    <member name="M:W.Logging.Log.LogMessageHistory.#ctor(System.Boolean)">
      <summary>
            Constructs a new LogMessageHistory
            </summary>
      <param name="newestFirst">If True, log messages are inserted at the start of the collection rather than appended to the end</param>
    </member>
    <member name="T:W.IOwnedProperty">
      <summary>
        <para>
            Used by PropertyHostMethods.InitializeProperties to find properties on which to set the owner.  This interface is not used by self-owned properties.
            </para>
      </summary>
    </member>
    <member name="M:W.IOwnedProperty.SetOwner(System.Object)">
      <summary>
            Sets the property owner to the specified value
            </summary>
      <param name="owner">The new property owner</param>
    </member>
    <member name="T:W.IProperty`1">
      <summary>
            The base interface which Property must support
            </summary>
      <typeparam name="TValue">The type of value for the property</typeparam>
    </member>
    <member name="P:W.IProperty`1.Value">
      <summary>
            The value of the property
            </summary>
    </member>
    <member name="T:W.IProperty">
      <summary>
            The base interface which Property must support
            </summary>
    </member>
    <member name="P:W.IProperty.IsDirty">
      <summary>
            True if the property's value has changed since initialization or since the last call to MarkAsClean
            </summary>
    </member>
    <member name="T:W.Property`2">
      <summary>
            A generic Property with an owner
            </summary>
      <typeparam name="TOwner">The type of owner</typeparam>
      <typeparam name="TValue">The type of the property value</typeparam>
    </member>
    <member name="M:W.Property`2.#ctor">
      <summary>
            Constructs a new Property
            </summary>
    </member>
    <member name="M:W.Property`2.#ctor(`1)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="defaultValue">The default and initial value of the property</param>
    </member>
    <member name="M:W.Property`2.#ctor(W.PropertyBase{`0,`1}.OnValueChangedDelegate)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="onValueChanged">A callback for when the property value changes</param>
    </member>
    <member name="M:W.Property`2.#ctor(`1,W.PropertyBase{`0,`1}.OnValueChangedDelegate)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="defaultValue">The default and initial value of the property</param>
      <param name="onValueChanged">A callback for when the property value changes</param>
    </member>
    <member name="M:W.Property`2.#ctor(`0)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="owner">The owner of the property</param>
    </member>
    <member name="M:W.Property`2.#ctor(`0,`1)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="owner">The owner of the property</param>
      <param name="defaultValue">The default and initial value of the property</param>
    </member>
    <member name="M:W.Property`2.#ctor(`0,W.PropertyBase{`0,`1}.OnValueChangedDelegate)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="owner">The owner of the property</param>
      <param name="onValueChanged">A callback for when the property value changes</param>
    </member>
    <member name="M:W.Property`2.#ctor(`0,`1,W.PropertyBase{`0,`1}.OnValueChangedDelegate)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="owner">The owner of the property</param>
      <param name="defaultValue">The default and initial value of the property</param>
      <param name="onValueChanged">A callback for when the property value changes</param>
    </member>
    <member name="T:W.Property`1">
      <summary>
            A generic Property with no owner (self-owned)
            </summary>
      <typeparam name="TValue">The type of the property value</typeparam>
    </member>
    <member name="M:W.Property`1.#ctor">
      <summary>
            Constructs a new Property
            </summary>
    </member>
    <member name="M:W.Property`1.#ctor(`0)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="defaultValue">The default and initial value of the property value</param>
    </member>
    <member name="M:W.Property`1.#ctor(W.PropertyBase{W.Property{`0},`0}.OnValueChangedDelegate)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="onValueChanged">A callback for when the property value changes</param>
    </member>
    <member name="M:W.Property`1.#ctor(`0,W.PropertyBase{W.Property{`0},`0}.OnValueChangedDelegate)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="defaultValue">The default and initial value of the property value</param>
      <param name="onValueChanged">A callback for when the property value changes</param>
    </member>
    <member name="T:W.PropertyBase`2">
      <summary>
            Provides the functionality for the Property classes
            </summary>
      <typeparam name="TOwner">The type of the property owner</typeparam>
      <typeparam name="TValue">The type of the property value</typeparam>
    </member>
    <member name="T:W.PropertyBase`2.PropertyValueChangingDelegate">
      <summary>
            Raised prior to the value of the property changing.  Allows the programmer to cancel the change.
            </summary>
      <param name="owner">The owner of the property</param>
      <param name="oldValue">The old value</param>
      <param name="newValue">The expected new value</param>
      <param name="cancel">Set to True to prevent the property value from changing</param>
    </member>
    <member name="T:W.PropertyBase`2.PropertyValueChangedDelegate">
      <summary>
            Raised when the value of the property changes
            </summary>
      <param name="sender">
      </param>
      <param name="oldValue">
      </param>
      <param name="newValue">
      </param>
    </member>
    <member name="T:W.PropertyBase`2.OnValueChangedDelegate">
      <summary>
            Used by the constructor to handle the property change via a callback rather than the events
            </summary>
      <param name="owner">The property owner</param>
      <param name="oldValue">The previous value</param>
      <param name="newValue">The new value</param>
    </member>
    <member name="E:W.PropertyBase`2.ValueChanged">
      <summary>
            Raised after Value has changed
            </summary>
    </member>
    <member name="E:W.PropertyBase`2.ValueChanging">
      <summary>
            Raised before Value has changed.  To prevent Value from changing set cancel to true.
            </summary>
    </member>
    <member name="F:W.PropertyBase`2.OnValueChanged">
      <summary>
            Callback type for use in the constructor (if one wants to avoid using the event)
            </summary>
    </member>
    <member name="P:W.PropertyBase`2.IsDirty">
      <summary>
            True if Value has changed since initialization or since the last call to MarkAsClean
            </summary>
    </member>
    <member name="P:W.PropertyBase`2.Owner">
      <summary>
            The property owner
            </summary>
    </member>
    <member name="P:W.PropertyBase`2.DefaultValue">
      <summary>
        <para>
            Allows the programmer to assign a default value which can be reset via the ResetToDefaultValue method. This value does not have to be the initial value.
            </para>
      </summary>
    </member>
    <member name="M:W.PropertyBase`2.ResetToDefaultValue(System.Boolean)">
      <summary>
            Resets the Value to the value provided by DefaultValue
            </summary>
      <param name="raise">If True, raise OnPropertyChanged event and call the OnValueChanged callback</param>
    </member>
    <member name="P:W.PropertyBase`2.Value">
      <summary>
            Get/Set the actual value of the Property
            </summary>
    </member>
    <member name="M:W.PropertyBase`2.WaitForChanged(System.Int32)">
      <summary>
            Allows the caller to suspend it's thread until Value changes
            </summary>
      <param name="msTimeout">The number of milliseconds to wait for the value to change</param>
      <returns>True if the value changed within the specified timeout period, otherwise False</returns>
    </member>
    <member name="M:W.PropertyBase`2.LoadValue(`1)">
      <summary>
            Loads Value without raising events or calling the OnValueChanged callback
            </summary>
      <remarks>Calling LoadValue sets IsDirty to false</remarks>
      <param name="value">The new value</param>
    </member>
    <member name="M:W.PropertyBase`2.GetValue">
      <summary>
            Gets the property value
            </summary>
      <returns>The property value</returns>
    </member>
    <member name="M:W.PropertyBase`2.SetValue(System.Object,System.String)">
      <summary>
            Sets the property value
            </summary>
      <param name="value">The new property value</param>
      <param name="callerMemberName">For logging purposes; it's not necessary to set</param>
    </member>
    <member name="M:W.PropertyBase`2.OnPropertyChanged(System.String)">
      <summary>
            Raises the OnPropertyChanged event
            </summary>
      <param name="propertyName">The name of the property which changed</param>
    </member>
    <member name="M:W.PropertyBase`2.ExecuteOnValueChanged(`1,`1)">
      <summary>
            Calls the OnValueChanged callback
            </summary>
      <param name="oldValue">The old property value</param>
      <param name="newValue">The new property value</param>
    </member>
    <member name="M:W.PropertyBase`2.RaisePropertyValueChanging(`1,`1,System.Boolean@)">
      <summary>
            Raises the ValueChanging event
            </summary>
      <param name="oldValue">The old property value</param>
      <param name="newValue">The expected new property value</param>
      <param name="cancel">Set to True to cancel the property change</param>
    </member>
    <member name="M:W.PropertyBase`2.RaisePropertyValueChanged(`1,`1)">
      <summary>
            Raises the PropertyValueChanged event
            </summary>
      <param name="oldValue">The old property value</param>
      <param name="newValue">The new property value</param>
    </member>
    <member name="M:W.PropertyBase`2.Dispose">
      <summary>
            Disposes the object and releases resources
            </summary>
    </member>
    <member name="M:W.PropertyBase`2.Finalize">
      <summary>
            Disposes the PropertyBase
            </summary>
    </member>
    <member name="T:W.PropertyChangedNotifier">
      <summary>
        <para>
            This is a base class for supporting INotifyPropertyChanged
            </para>
      </summary>
    </member>
    <member name="E:W.PropertyChangedNotifier.PropertyChanged">
      <summary>
            Raised when a property changes
            </summary>
    </member>
    <member name="M:W.PropertyChangedNotifier.GetValue">
      <summary>
        <para>
            Override this method to provide Get functionality
            </para>
      </summary>
      <returns>Unless overridden, this function will always return null</returns>
    </member>
    <member name="M:W.PropertyChangedNotifier.SetValue(System.Object,System.String)">
      <summary>
        <para>
            Calls OnPropertyChanged.  This method does not make assignments.  Override this method to make assignments.
            </para>
      </summary>
      <param name="value">The new value</param>
      <param name="propertyName">The name of the caller (the property being set)</param>
    </member>
    <member name="M:W.PropertyChangedNotifier.OnPropertyChanged(System.String)">
      <summary>
        <para>
            Calls RaisePropertyChanged to raise the PropertyChanged event
            </para>
      </summary>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="M:W.PropertyChangedNotifier.RaiseOnPropertyChanged(System.Object,System.String)">
      <summary>
        <para>
            Raises the PropertyChanged event
            </para>
      </summary>
      <param name="sender">The sender is the owner of the property</param>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="T:W.PropertyHost">
      <summary>
        <para>
            Provides a base class to automate the IsDirty, MarkAsClean and InitializeProperties functionality
            Note that this class does not support INotifyPropertyChanged and is not intented to host owned properties (though nothing prevents you from doing so)
            </para>
      </summary>
    </member>
    <member name="P:W.PropertyHost.IsDirty">
      <summary>
            Finds all Properties and checks their IsDirty flag
            </summary>
      <returns>True if any Property's IsDirty flag is true. Otherwise false.</returns>
    </member>
    <member name="M:W.PropertyHost.MarkAsClean">
      <summary>
            Uses reflection to find all Properties and mark them as clean (call Property.MarkAsClean())
            </summary>
    </member>
    <member name="M:W.PropertyHost.#ctor">
      <summary>
            Calls PropertyHostMethods.InitializeProperties so you don't have to
            </summary>
    </member>
    <member name="T:W.PropertyHostMethods">
      <summary>
            Exposes static PropertyHost extension methods
            </summary>
    </member>
    <member name="M:W.PropertyHostMethods.InitializeProperties(System.Object)">
      <summary>
        <para>
            Scans the fields and properties of "owner" and sets the member's Owner property to "owner"
            This method should be called in the constructor of any class which has IOwnedProperty members
            </para>
      </summary>
      <param name="this">The object on which to find and initialize properties</param>
    </member>
    <member name="M:W.PropertyHostMethods.IsDirty(System.Object)">
      <summary>
        <para>
            Scans the IsDirty value of each field and property of type IProperty 
            </para>
      </summary>
      <param name="this">The object on which to inspect for dirty properties</param>
      <returns>True if any IProperty member's IsDirty value is true, otherwise false</returns>
    </member>
    <member name="M:W.PropertyHostMethods.MarkAsClean(System.Object)">
      <summary>
        <para>
            Scans each field and property of type IProperty and sets it's IsDirty flag to false
            </para>
      </summary>
      <param name="this">The object on which to mark all properties as clean</param>
    </member>
    <member name="T:W.PropertyHostNotifier">
      <summary>
        <para>
            Provides a base class to automate the IsDirty, MarkAsClean and InitializeProperties functionality
            Note that this class inherits PropertyChangedNotifier for INotifyPropertyChanged support
            </para>
      </summary>
    </member>
    <member name="P:W.PropertyHostNotifier.IsDirty">
      <summary>
            Finds all Properties and checks their IsDirty flag
            </summary>
      <returns>True if any Property's IsDirty flag is true. Otherwise false.</returns>
    </member>
    <member name="M:W.PropertyHostNotifier.MarkAsClean">
      <summary>
            Uses reflection to find all Properties and mark them as clean (call Property.MarkAsClean())
            </summary>
    </member>
    <member name="M:W.PropertyHostNotifier.#ctor">
      <summary>
            Calls PropertyHostMethods.InitializeProperties so you don't have to
            </summary>
    </member>
    <member name="M:W.PropertyMethods.SetValue``1(System.Object,``0@,``0,System.Action{``0,``0,System.String},System.String)">
      <summary>
            Provides thread-safe assignment of a variable and invoking a handler when the change occurs
            </summary>
      <returns>True if the assignment was made, otherwise false</returns>
    </member>
    <member name="M:W.PropertyMethods.LoadValue``1(System.Object,``0@,``0)">
      <summary>
            Provides thread-safe assignment of a variable
            </summary>
      <returns>True if the assignment was made, otherwise false</returns>
    </member>
    <member name="M:W.PropertyMethods.SetValue``1(W.Lockable{``0},``0,System.Action{``0,``0,System.String},System.String)">
      <summary>
            Provides thread-safe assignment of a Lockable object and invoking a handler when the change occurs
            </summary>
      <returns>True if the assignment was made, otherwise false</returns>
    </member>
    <member name="M:W.PropertyMethods.LoadValue``1(W.Lockable{``0},``0)">
      <summary>
            Provides thread-safe assignment of a Lockable object
            </summary>
      <returns>True if the assignment was made, otherwise false</returns>
    </member>
    <member name="T:W.Singleton`1">
      <summary>
            Thread-safe Singleton implementation
            </summary>
      <typeparam name="TSingletonType">The singleton Type</typeparam>
      <remarks>Adapted from MSDN article "Implementing Singleton in C#"</remarks>
      <see ref="https://msdn.microsoft.com/en-us/library/ff650316.aspx">MSDN Article: Implementing Singleton in C#</see>
    </member>
    <member name="P:W.Singleton`1.Instance">
      <summary>
            Returns the singleton
            </summary>
    </member>
    <member name="T:W.StringExtensions">
      <summary>
            Some useful string extensions
            </summary>
    </member>
    <member name="M:W.StringExtensions.IsValidBase64(System.String)">
      <summary>
            Validates the given string conforms to Base64 encoding.  It does not verify the value is a Base64 encoded value.
            </summary>
      <param name="value">The string to test</param>
      <returns>True if the value is valid Base64, otherwise false</returns>
      <remarks>
        <para>This solution is based on a StackOverflow <see href="http://stackoverflow.com/questions/8571501/how-to-check-whether-the-string-is-base64-encoded-or-not">answer</see></para>
      </remarks>
    </member>
    <member name="T:W.Threading.CPUProfileEnum">
      <summary>
            The preferred level of CPU usage
            </summary>
    </member>
    <member name="F:W.Threading.CPUProfileEnum.SpinWait0">
      <summary>High CPU usage, but fastest execution.  May be faster on single-core/cpu machines.  May be slower on multi-core/cpu machines.</summary>
    </member>
    <member name="F:W.Threading.CPUProfileEnum.Sleep">
      <summary>Medium CPU usage.  Uses Thread.Sleep or Task.Delay to block the current thread.</summary>
    </member>
    <member name="F:W.Threading.CPUProfileEnum.SpinWait1">
      <summary>Low CPU usage.  Should be faster on multi-core/cpu machines as the load will be divided among cores/cpus.  Slowest on single-core/cpu machines.</summary>
    </member>
    <member name="F:W.Threading.CPUProfileEnum.Yield">
      <summary>Only available for .Net Framework; uses Thread.Yield instead of Thread.Sleep.</summary>
    </member>
    <member name="T:W.Threading.Gate`1">
      <summary>
            A thread Gate which supports passing in a typed parameter
            </summary>
      <typeparam name="TParameterType">The type of parameter that will be passed to the gated thread procedure</typeparam>
    </member>
    <member name="M:W.Threading.Gate`1.CallAction(System.Threading.CancellationToken)">
      <summary>
            Invokes the gated Action
            </summary>
      <param name="token">The CancellationToken which is passed into the Action and should be used to monitor whether the Gate has been cancelled</param>
    </member>
    <member name="M:W.Threading.Gate`1.Run">
      <summary>
            Opens the gate (allows the gated Action to be called), passing in the default value which was specified in the constructor
            </summary>
    </member>
    <member name="M:W.Threading.Gate`1.Run(`0)">
      <summary>
            Opens the gate (allows the gated Action to be called), passing in the specified typed value
            </summary>
      <param name="arg">The argument to pass into the gated Action</param>
    </member>
    <member name="M:W.Threading.Gate`1.#ctor(System.Action{`0,System.Threading.CancellationToken})">
      <summary>
            Constructs a new Gate
            </summary>
      <param name="action">The Action to call when the gate is opened</param>
    </member>
    <member name="M:W.Threading.Gate`1.#ctor(System.Action{`0,System.Threading.CancellationToken},`0)">
      <summary>
            Constructs a new Gate
            </summary>
      <param name="action">The Action to call when the gate is opened</param>
      <param name="defaultArg">A default value which will be passed to the gated Action, if not otherwise specified</param>
    </member>
    <member name="T:W.Threading.Gate">
      <summary>
            A thread Gate is a background thread which is initially closed.  When a Gate is opened, the Action runs until completion.  The Gate can be opened (Run) any number of times.
            </summary>
    </member>
    <member name="M:W.Threading.Gate.CallAction(System.Threading.CancellationToken)">
      <summary>
            Invokes the gated Action
            </summary>
      <param name="token">The CancellationToken which is passed into the Action and should be used to monitor whether the Gate has been cancelled</param>
    </member>
    <member name="P:W.Threading.Gate.IsRunning">
      <summary>
            True if the Gate is currently open (running), otherwise False
            </summary>
    </member>
    <member name="P:W.Threading.Gate.IsComplete">
      <summary>
            True if the gated Action has completed, otherwise False
            </summary>
    </member>
    <member name="M:W.Threading.Gate.Run">
      <summary>
            Signals the thread to open the gate (allows the gated Action to be called).
            </summary>
    </member>
    <member name="M:W.Threading.Gate.Join">
      <summary>
            Blocks the calling thread until the gated Action is complete
            </summary>
    </member>
    <member name="M:W.Threading.Gate.Join(System.Int32)">
      <summary>
            Blocks the calling thread until the gated Action is complete, or until the specified number of milliseconds has elapsed
            </summary>
      <param name="msTimeout">The number of milliseconds to wait for the gate to complete before timing out and returning False</param>
      <returns>True if the gate completed within the specified timeout, otherwise False</returns>
    </member>
    <member name="M:W.Threading.Gate.Cancel">
      <summary>
            Singals the gated Action that a Cancel has been requested
            </summary>
    </member>
    <member name="M:W.Threading.Gate.Dispose">
      <summary>
            Cancels the gated Action, disposes the Gate and releases resources
            </summary>
    </member>
    <member name="M:W.Threading.Gate.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Constructs a new Gate
            </summary>
      <param name="action">The Action to call when the gate is opened</param>
    </member>
    <member name="T:W.Threading.GateMethods">
      <summary>
            Extension methods on Action to Create a Gate
            </summary>
    </member>
    <member name="M:W.Threading.GateMethods.AsGate(System.Action{System.Threading.CancellationToken})">
      <summary>
            Creates a Gate with the supplied action
            </summary>
      <param name="action">The Action to call when the gate is relased (when Run is called)</param>
      <returns>A reference to a new Gate</returns>
    </member>
    <member name="M:W.Threading.GateMethods.AsGate``1(System.Action{``0,System.Threading.CancellationToken})">
      <summary>
            Creates a Gate with the supplied action
            </summary>
      <typeparam name="TParameterType">The Type of the parameter to be passed in</typeparam>
      <param name="action">The Action to call when the gate is released (when Run is called)</param>
      <returns>A reference to a new Gate</returns>
    </member>
    <member name="T:W.Threading.Thread`1">
      <summary>
            A thread class which can pass a typed parameter into the thread action
            </summary>
      <typeparam name="TParameterType">The argument Type to be passed into the thread action</typeparam>
    </member>
    <member name="M:W.Threading.Thread`1.CallAction(System.Threading.CancellationToken)">
      <summary>
            Calls the action encapsulated by this thread.  This method can be overridden to provide more specific functionality.
            </summary>
      <param name="token">The CancellationToken, passed into the action, which can be used to cancel the thread Action</param>
    </member>
    <member name="M:W.Threading.Thread`1.Start">
      <summary>
            Starts the thread if it's not already running
            </summary>
    </member>
    <member name="M:W.Threading.Thread`1.Start(System.Int32)">
      <summary>
            Starts the thread if it's not already running
            </summary>
      <param name="msLifetime">The number of milliseconds before the thread is automatically cancelled. A negative value indicates an infinite lifetime.</param>
    </member>
    <member name="M:W.Threading.Thread`1.Start(`0)">
      <summary>
            Starts the thread if it's not already running, passing in the specified argument
            </summary>
      <param name="arg">The argument to pass into the threaded Action</param>
    </member>
    <member name="M:W.Threading.Thread`1.Start(`0,System.Int32)">
      <summary>
            Starts the thread if it's not already running
            </summary>
      <param name="arg">The argument to pass into the threaded Action</param>
      <param name="msLifetime">The number of milliseconds before the thread is automatically cancelled. A negative value indicates an infinite lifetime.</param>
    </member>
    <member name="M:W.Threading.Thread`1.#ctor(System.Action{`0,System.Threading.CancellationToken})">
      <summary>
            Constructs a new Thread which can accept a parameter
            </summary>
      <param name="action">The CancellationToken which can be used to cancel the thread</param>
      <remarks>Calling this constructor will automatically start the thread</remarks>
    </member>
    <member name="M:W.Threading.Thread`1.#ctor(System.Action{`0,System.Threading.CancellationToken},System.Boolean)">
      <summary>
            Constructs a new Thread which can accept a parameter
            </summary>
      <param name="action">The CancellationToken which can be used to cancel the thread</param>
      <param name="autoStart">If True, the Thread will immediately start, otherwise the Start method will have to be called manually</param>
    </member>
    <member name="M:W.Threading.Thread`1.#ctor(System.Action{`0,System.Threading.CancellationToken},`0)">
      <summary>
            Constructs a new Thread which can accept a parameter
            </summary>
      <param name="action">The CancellationToken which can be used to cancel the thread</param>
      <param name="defaultArg">The default argument to pass into the thread procedure</param>
      <remarks>Calling this constructor will automatically start the thread</remarks>
    </member>
    <member name="M:W.Threading.Thread`1.#ctor(System.Action{`0,System.Threading.CancellationToken},`0,System.Boolean)">
      <summary>
            Constructs a new Thread which can accept a parameter
            </summary>
      <param name="action">The CancellationToken which can be used to cancel the thread</param>
      <param name="defaultArg">The default argument to pass into the thread procedure</param>
      <param name="autoStart">If True, the Thread will immediately start, otherwise the Start method will have to be called manually</param>
    </member>
    <member name="T:W.Threading.Thread">
      <summary>
            A thread class
            </summary>
    </member>
    <member name="M:W.Threading.Thread.CallAction(System.Threading.CancellationToken)">
      <summary>
            Calls the action encapsulated by this thread.  This method can be overridden to provide more specific functionality.
            </summary>
      <param name="token">The CancellationToken, passed into the action, which can be used to cancel the thread Action</param>
    </member>
    <member name="P:W.Threading.Thread.IsStarted">
      <summary>
            True if the thread has been started, otherwise False
            </summary>
    </member>
    <member name="P:W.Threading.Thread.IsComplete">
      <summary>
            True if the thread has completed, otherwise False
            </summary>
      <remarks>A True value does not indicate that the thread completed successfully</remarks>
    </member>
    <member name="P:W.Threading.Thread.IsFaulted">
      <summary>
            True if the thread raised an exception, otherwise False
            </summary>
    </member>
    <member name="P:W.Threading.Thread.Exception">
      <summary>
            The exception, if one was caught
            </summary>
    </member>
    <member name="P:W.Threading.Thread.Token">
      <summary>
            Not available until after Start has been called
            </summary>
    </member>
    <member name="M:W.Threading.Thread.Join">
      <summary>
            Block the calling thread until this thread object has completed
            </summary>
    </member>
    <member name="M:W.Threading.Thread.Join(System.Int32)">
      <summary>
            Block the calling thread until this thread object has completed or until the timeout has occurred
            </summary>
      <param name="msTimeout">The number of milliseconds to wait, for the thread Action to complete, before timing out</param>
      <returns>True if the thread Action completed within the specified timeout, otherwise False</returns>
    </member>
    <member name="M:W.Threading.Thread.Start">
      <summary>
            Start the thread
            </summary>
    </member>
    <member name="M:W.Threading.Thread.Start(System.Int32)">
      <summary>
            Start the thread with a CancellationToken which will timeout in the specified milliseconds
            </summary>
      <param name="msLifetime">The number of milliseconds before the thread is automatically cancelled. A negative value indicates an infinite lifetime.</param>
    </member>
    <member name="M:W.Threading.Thread.Stop">
      <summary>
            Stop the thread.  This calls Cancel on the CancellationToken
            </summary>
    </member>
    <member name="M:W.Threading.Thread.Dispose">
      <summary>
            Dispose the thread and free resources
            </summary>
    </member>
    <member name="M:W.Threading.Thread.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Constructs a new Thread
            </summary>
      <param name="action">The action to call on a thread</param>
    </member>
    <member name="M:W.Threading.Thread.#ctor(System.Action{System.Threading.CancellationToken},System.Boolean)">
      <summary>
            Constructs a new Thread
            </summary>
      <param name="action">The action to call on a thread</param>
      <param name="autoStart">If True, the thread will immediately start.  Otherwise Start will have to be called.</param>
    </member>
    <member name="M:W.Threading.Thread.Cancel">
      <summary>
            Cancel the thread
            </summary>
    </member>
    <member name="P:W.Threading.Thread.IsRunning">
      <summary>
            True if the thread is currently running, otherwise False
            </summary>
    </member>
    <member name="M:W.Threading.Thread.Sleep(System.Int32)">
      <summary>
            Blocks the calling thread for the specified time
            </summary>
      <param name="msDelay">The number of milliseconds to block the thread</param>
    </member>
    <member name="M:W.Threading.Thread.Sleep(System.Int32,System.Boolean)">
      <summary>
            Blocks the calling thread for the specified time
            </summary>
      <param name="msDelay">The number of milliseconds to block the thread</param>
      <param name="useSpinWait">If True, a SpinWait.SpinUntil will be used instead of a call to Thread.Sleep (or Task.Delay).  Note that SpinWait should only be used on multi-core/cpu machines.</param>
    </member>
    <member name="M:W.Threading.Thread.Sleep(W.Threading.CPUProfileEnum)">
      <summary>
            Attempts to free the CPU for other processes, based on the desired level.  Consequences will vary depending on your hardware architecture.  The more processors/cores you have, the better performance you will have by selecting LowCPU.  Likewise, on a single-core processor, you may wish to select HighCPU.
            </summary>
      <param name="level">The desired level of CPU usage</param>
      <remarks>Note results may vary.  LowCPU will spread the load onto multiple cores and can actually yield faster results depending on your hardware architecture.  This may not always be the case.</remarks>
    </member>
    <member name="M:W.Threading.Thread.Create(System.Action{System.Threading.CancellationToken})">
      <summary>
            Starts a new thread
            </summary>
      <param name="action">Action to call on a thread</param>
      <returns>A new Thread</returns>
    </member>
    <member name="M:W.Threading.Thread.Create(System.Action{System.Threading.CancellationToken},System.Boolean)">
      <summary>
            Starts a new thread
            </summary>
      <param name="action">Action to call on a thread</param>
      <param name="autoStart">If True, the thread immediately starts</param>
      <returns>A new Thread</returns>
    </member>
    <member name="M:W.Threading.Thread.Create``1(System.Action{``0,System.Threading.CancellationToken})">
      <summary>
            Creates and starts a new thread
            </summary>
      <typeparam name="TParameterType">The argument Type to be passed into the thread action</typeparam>
      <param name="action">Action to call on a thread</param>
      <returns>A new Thread</returns>
    </member>
    <member name="M:W.Threading.Thread.Create``1(System.Action{``0,System.Threading.CancellationToken},System.Boolean)">
      <summary>
            Creates a new thread
            </summary>
      <typeparam name="TParameterType">The argument Type to be passed into the thread action</typeparam>
      <param name="action">Action to call on a thread</param>
      <param name="autoStart">If True, the thread is immediately started</param>
      <returns>A new Thread</returns>
    </member>
    <member name="T:W.Threading.ThreadExtensions">
      <summary>
            Contains a generic extension method to quickly start a new thread
            </summary>
    </member>
    <member name="M:W.Threading.ThreadExtensions.CreateThread``1(``0,System.Action{``0,System.Threading.CancellationToken})">
      <summary>
            Creates and starts a new thread
            </summary>
      <typeparam name="TParameterType">The Type of the item being extended</typeparam>
      <param name="this">The object to send into a new Thread</param>
      <param name="action">Action to call on a thread</param>
      <returns>A reference to the new W.Threading.Thread&lt;T&gt;</returns>
    </member>
    <member name="M:W.Threading.ThreadExtensions.CreateThread``1(``0,System.Action{``0,System.Threading.CancellationToken},System.Boolean)">
      <summary>
            Creates a new thread
            </summary>
      <typeparam name="TParameterType">The Type of the item being extended</typeparam>
      <param name="this">The object to send into a new Thread</param>
      <param name="action">Action to call on a thread</param>
      <param name="autoStart">If True, the thread will immediately start running</param>
      <returns>A reference to the new W.Threading.Thread&lt;T&gt;</returns>
    </member>
    <member name="M:W.Threading.ThreadExtensions.CreateThread``1(System.Object,System.Action{``0,System.Threading.CancellationToken})">
      <summary>
            Creates and starts a new thread and 
            </summary>
      <typeparam name="TParameterType">The Type of the item being extended</typeparam>
      <param name="this">The object to send into a new Thread</param>
      <param name="action">Action to call on a thread</param>
      <returns>A reference to the new W.Threading.Thread&lt;T&gt;</returns>
    </member>
    <member name="M:W.Threading.ThreadExtensions.CreateThread``1(System.Object,System.Action{``0,System.Threading.CancellationToken},System.Boolean)">
      <summary>
            Creates a new thread
            </summary>
      <typeparam name="TParameterType">The Type of the item being extended</typeparam>
      <param name="this">The object to send into a new Thread</param>
      <param name="action">Action to call on a thread</param>
      <param name="autoStart">If True, the thread will immediately start running</param>
      <returns>A reference to the new W.Threading.Thread&lt;T&gt;</returns>
    </member>
    <member name="T:W.ExtensionMethods">
      <summary>
            Tungsten extension methods
            </summary>
    </member>
    <member name="M:W.ExtensionMethods.Lock``1(``0,System.Action{``0})">
      <summary>
            Performs the given action in a lock statement using the provided object for the lock
            </summary>
      <typeparam name="TItemType">The type of object on which the lock is made</typeparam>
      <param name="this">The object to use in the lock</param>
      <param name="action">The action to perform in a lock statement</param>
      <code>
            someValue.Lock(value =&gt; { value += 10; }); //lock on someValue and pass it into the action
            </code>
    </member>
    <member name="M:W.ExtensionMethods.WaitForValueAsync(System.Object,System.Object,System.Int32)">
      <summary>
            Initiates a Task which will wait for the given variable to have the specified value
            </summary>
      <param name="this">The value being inspected</param>
      <param name="desiredValue">The value to wait for</param>
      <param name="msTimeout">The task will time out within the specified number of milliseconds.  Use -1 to wait indefinitely.</param>
      <returns>True if the value was acquired within the specified timeout, otherwise False</returns>
    </member>
    <member name="M:W.ExtensionMethods.WaitForValueAsync``1(``0,System.Predicate{``0},System.Int32)">
      <summary>
            Initiates a Task which will wait for the specified condition to be met
            </summary>
      <typeparam name="TItemType">The object Type of the item being extended</typeparam>
      <param name="this">The value being inspected</param>
      <param name="predicate">The condition to be met</param>
      <param name="msTimeout">The task will time out within the specified number of milliseconds.  Use -1 to wait indefinitely.</param>
      <returns>True if the condition was met within the specified timeout, otherwise False</returns>
    </member>
    <member name="M:W.ExtensionMethods.WaitForValue``1(``0,System.Predicate{``0},System.Int32)">
      <summary>
            Initiates a Task which will wait for the specified condition to be met
            </summary>
      <typeparam name="TItemType">The object Type of the item being extended</typeparam>
      <param name="this">The value being inspected</param>
      <param name="predicate">The condition to be met</param>
      <param name="msTimeout">The task will time out within the specified number of milliseconds.  Use -1 to wait indefinitely.</param>
      <returns>True if the condition was met within the specified timeout, otherwise False</returns>
    </member>
    <member name="M:W.ExtensionMethods.Raise(System.Delegate,System.Object[])">
      <summary>
            Calls the delegate, passing in any arguments.  Provides error handling to allow all subscribers to handle the delegate.
            </summary>
      <param name="del">The delegate to call</param>
      <param name="args">Parameters to pass into the delegate</param>
      <returns>Exceptions if any are thrown</returns>
    </member>
    <member name="N:W">
      <summary>The root namespace for Tungsten.  W is used because it is the symbol for Tungsten on the periodic table of elements.</summary>
    </member>
    <member name="N:W.Encryption">
      <summary>Functionality related to encryption</summary>
    </member>
    <member name="N:W.Logging">
      <summary>Functionality related to information and error logging</summary>
    </member>
    <member name="N:W.Threading">
      <summary>Functionality related to multi-threading</summary>
    </member>
  </members>
</doc>